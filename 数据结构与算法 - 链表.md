# 链表
---

[TOC]

## 基础知识





## 相关技巧





## 反转链表

- [哑巴节点](https://leetcode-cn.com/problems/reverse-linked-list/)
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

/** 
   迭代法：
   猜测：由于链表会被改变，因此需要使用哑巴节点进行辅助
**/
class Solution {
public:
    ListNode* reverseList(ListNode* head) {

        if (head == NULL) return NULL;

        ListNode* pre = NULL;
        ListNode* cur = head;
        ListNode* nxt;

        while (cur) {
            nxt = cur->next;

            cur->next = pre;
            pre = cur;
            cur = nxt;
        }

        return pre;

    }
};

/**
	递归法
		1. terminator 终止条件！可对比迭代法进行思考
       	2. process current level 处理当前层的逻辑，对比迭代法 
		3. drill down 递归
		4. reverse state if need 如果需要，恢复变量状态
**/
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        return reverse(head, NULL);
    }

    ListNode* reverse(ListNode* cur, ListNode* pre) {
        if (cur == NULL) return pre;  // 当cur到链表尾时，pre为修改后的链表头节点

        ListNode* nxt = cur->next;
        cur->next = pre;
        pre = cur;
        cur = nxt;

        return reverse(cur, pre);
    }
};
```
## 两两交换链表中的节点
- [哑巴节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

 /**
    迭代法：
        使用哑巴节点进行辅助，因为原链表被修改了
        链表的题目一定要细心
        比如：在修改该节点前，一定要先将该节点的next节点单独提取出来
 **/
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {

        if (head == NULL || head->next == NULL) return head;

        ListNode* dummy = new ListNode();
        dummy->next = head;
        ListNode* pre = dummy;
        ListNode* cur = head;
        ListNode* nxt;
        ListNode* temp;

        while (cur != NULL && cur->next != NULL) {
            nxt = cur->next;
            temp = nxt->next;

            pre->next = nxt;
            nxt->next = cur;
            cur->next = temp;

            pre = cur;
            cur = temp;
        }

        return dummy->next;
    }
};

/**
    递归法： 完全可以对照迭代法写！ 
            迭代 & 递归的逻辑完全相同
            需要理解的是递归的四部曲如何操作
    递归四部曲：
        1. terminator
        2. process current level
        3. drill down
        4. reverse state if needed 
 **/
class Solution {
public:
    void swap(ListNode*cur, ListNode* pre) {
        if (cur == NULL || cur->next == NULL) return;

        ListNode* nxt = cur->next;
        ListNode* temp = nxt->next;

        pre->next = nxt;
        nxt->next = cur;
        cur->next = temp;

        pre = cur;
        cur = temp;

        swap(cur, pre);
    }

    ListNode* swapPairs(ListNode* head) {
        ListNode* dummy = new ListNode();
        dummy->next = head;
        ListNode* pre = dummy;
        swap(head, pre);
        return dummy->next;
    }
};
```
## 环形链表
- [双指针-快慢指针](https://leetcode-cn.com/problems/linked-list-cycle/)
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
    	/**
        快慢指针解题：
            快指针每次走两步
            慢指针每次走一步
            如果两个指针可以相遇则有环
            否则无环
        **/
    	
        if (head == NULL || head->next == NULL) return false;

        ListNode* slow = head;
        ListNode* fast = head->next;

        while (fast != NULL && fast->next != NULL) {
            if (slow == fast) return true;
            slow = slow->next;
            fast = fast->next->next;
        }
        return false;
    }
};
```